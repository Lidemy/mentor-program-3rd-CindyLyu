## 前四週心得與解題心得
### :seedling: 前四週心得
- 成長心得：
    - 之前公司內部也有工程師，上了前四週的課想起以前工程師講過的一些術語現在都好像比較明白了！就連工程師之前在跟老闆解釋 git 與 branch 時，覺得自己上完課也都懂了覺得很棒！
    - 每週作業越來越難的感覺，覺得學 JavaScript 比較花心力，第四週的網路基礎學完當下，有一點混亂的感覺，不過現在應該比較好了，很期待第六週可以做出頁面了，也稍微擔心後面會不會更難交不出作業，
    - 覺得這週需要再去多練習一些函式，之前像是作業或練習題有些都會禁止使用內建的函式，自己也沒常練習，就變成反而解題或做作業都沒使用到，要到看同學的 code 才想到可以使用。
    - 在課程中發現有些地方老師也會寫錯或教錯，然後老師也會當下去修正，但有時候自己也會覺得很混亂，想說剛剛發生什麼事情，到後面看到老師有說明其實是希望能夠讓我們看到老師的思考方式，就算錯了也沒有特意剪接掉，覺得好像能夠接受這說法，目前是覺得解題的影片好像比較沒差，但如果是教學的影片似乎會有點混亂，不過之前還不知道原來有這原因所以沒剪接掉，之後上課再來看看如何。
    - 剛開始交作業就是寫出來覺得很棒就交了，後來發現原來要寫得好才是好，於是之後作業寫完都會在多思考哪裡可以優化，每次寫完作業看同學的 code 發現自己都有很大的進步空間，說白一點就是自己寫的超爛，不知道是不是自己還想得不夠多，或是不夠熟練其他函式之類的。
    - 這週在複習時，看到自己的筆記關於交作業，push 後新增一個 issue 會有機器人通知同學來看，發現自己好像沒有看過機器人通知，是我錯過了什麼嗎？還是指的是標上組別標籤的意思呢。
- 學習分析：
    - 偶爾看影片上課會很催眠想睡（自己的問題），寫 code 就比較不會想睡一點，之後可以上課想睡的時候就去解一些題。
    - 原本第一二週覺得自己學習效率好像不太好，雖然進度都有跟到課綱內，後來決定使用番茄工作法，學習 25 分鐘，休息 5 分鐘，但後來發現會不小心超過休息的 5 分鐘，讓一天學習時間也變少，所以之後就乾脆一定要超過 25 分鐘後再休息，但不一定要 25 分鐘就休息，有可能拉長變一小時之類的，總之就是告一段落。
    - 好奇記錄自己的學習時間分佈，用了 [Toggl](https://toggl.com/) 軟體來輔助紀錄每天學習的時間，另外在自行記錄看影片時間，發現自己學習時間很零碎（圖表看不出來），每天大概都會學習到晚上睡前，但每天統計下來發現不一定超過 8 小時就是了，原因大概是自己做事情很拖延，像是吃午餐就花很多時間。（綠色代表當天學習的時間（不包含寫每日報告），較深的綠色長條圖代表假日；橘色為看課程影片的時間，紀錄不包含之後再次看看過的影片來複習或找一些片段內容影片時間，除非是類似複習整堂 NET101 課程或是第一次觀看課程影片這種好紀錄的時間才會紀錄；左邊縱軸代表時間 小時：分：秒）

![learningTime](https://imgur.com/Wa4NcV0.png)
- 一些外在因素：
    - 關於 Lidemy 平台播放課程影片，有一些困擾但比較個人主觀的習慣，就是影片看起來是依據網速來給予畫質，所以大多開啟影片都給 720p 的畫質，自己都會去手動調整到 1080p（也不太會 lag），但調整的話就是要每換一個影片就要調整一次很麻煩，看起來沒辦法像影片倍速或自動播放可以統一調整，不過這看來應該是 Teachable 平台那邊設定的就是了（自己還去查一下看沒有什麼方式可以騙網站網速的方式XD，也試過用 Safari 看，發現體驗更差，決定放棄）。
    - 以及播放下個影片都會跳轉到影片列表頁，就是需再次手動開啟全螢幕，大概是被 [好學校](https://hahow.in/) 平台給寵壞都不用手動去按全螢幕，可以自動播放下節影片並且一樣全螢幕，不過這都蠻個人主觀的想法，也比較偏向影片平台那邊的設定。





### :video_game: HTTP Game 闖關心得
記得在第四週寫完作業上傳後，想說來安排一下到第五週結束的學習計畫，也看了第五週的導讀，於是就發現的這個遊戲，進入遊戲後一直想繼續玩下去，可能是自己很愛玩遊戲，所以滿腦子都想要去闖關，但在剛開始不小心想的太複雜，所以第一關（告訴管理員名字）跟第九關（用 IE 發送 request）並列研究最久，但真的很好玩！非常喜歡，直接拋開已安排的學習計畫，將這個遊戲列為首要完成執行。

記得在進入第一關，看到劇情的內容腦中直接浮現遊戲及老爺爺的畫面，總覺得遊戲也會出現類似這種話「啊...好久沒有看到年輕人到我這個圖書館了」，以及每一關都貫穿老爺爺的個性（但好像根本沒有提到管理員的年紀），像是管理員不太懂資訊的使用、兩個關卡重複話語都是長輩的特性，在最後破完第十關決定去看每一關的提示看會不會有新的發現。

印象很深刻的除了第一關不小心想的太複雜，還有一剛開始很蠢的直接在這個網址 https://lidemy-http-challenge.herokuapp.com/start 後面貼上 /lv1?token={GOGOGO} 後來才發現要刪除 start 才行，還有第九關（用 IE 發送 request），還去安裝的可以切換到 IE 瀏覽器的擴充套件，但總是想不出來要如何用瀏覽器來發送 request 且包含著一些 headers 資訊，最後研究觀察多次檢查模式的 request headers 才想起直接在編輯器中將 headers 加入 `user-agent` 不就好了。

最後破到第十關後第十一關有點卡關，就先暫時告一段落。

另外好想知道全部的彩蛋，後來還回去再重新全部看一次，因為除了原本找到 5566 的彩蛋就沒有找到了，後來發現了疑似彩蛋的地方
1. 有人捐到收藏書
2. 韓國瑜的書被偷走
3. 找一本書叫做《大腦喜歡這樣學》書的 id 為 1989 是不是老師的出生年份（如果沒記錯之前忘記在哪裡看到老師有說今年要 30 歲了）

### :pencil2: NPSC 題目練習心得
1. **黑澀會美眉**：先是看錯題目，所以寫錯判斷，再來沒發現型態錯誤，所以這一題做了好久才完成。
在解題過程，覺得卡關所以隔天再回來解，瞬間覺得自己的 code 好難理解，自己之前都習慣在重寫一次，不要再回到卡關有盲點的 code，但也發現這樣的習慣似乎不一定好，因為未來工作上也會需要看原本公司產品內部的 code。

2. **不公平的人，是誰？**：原本測試平台拿到 92 分，想很久還是想不太到其他邊際的條件，或是有什麼漏掉的。
因為想不太到，就從根據題目嘗試做很細微也覺得蠻徒勞無功的調整看看，像是
    - 「該列從小郭的角度出發」所以把 if 的條件會回傳的 `Fair` 寫在最上面，之後再寫會傳 `Unfair` 的條件
    - 「射程必為一非負整數」寫判斷當 `m < 0 || n < 0` 就不執行內容，

    之後花了幾天零碎的時間想，還是嘗試失敗。

    ```javascript
    function pb(m, n) {
      if (parseInt(m) > parseInt(n)) {
        return 'Unfair'
      } else if (parseInt(m) <= parseInt(n)) {
        return 'Fair'
      }
    }
    ```
    感謝老師主動提示我，還是花了一些時間想及驗證才發現大數會變成無窮迴圈 Infinity，所以所以最後完成的程式碼如下。
    ```java
    function pb(m, n) {
      if (m.length > n.length) {
        return 'Unfair'
      } else if (m.length < n.length) {
        return 'Fair'
      }
      for (let i = 0; i < m.length; i ++) {
        if (parseInt(m[i]) > parseInt(n[i])) return 'Unfair'
        if (parseInt(m[i]) < parseInt(n[i])) return 'Fair'
      }
    }
    ```
    反思：覺得自己在遇到這種題目，應該先將邊際的條件參數印出來看是否與預期符合，在能確保之後的執行是對的
3. **打不倒的空氣人**：這題感覺簡單很多，就是把第一個陣列 `.join` 轉換成字串後，再利用第二個陣列內容去取前面字串的值，不過需要特別注意題目提到的「字串 index 由 1 開始」，這跟原本取值從 0 開始不太一樣就是了。

4. **白飯**：這題也很簡單的感覺，主要就是計算陣列中所有學生的分數來計算平均，並計算有幾位學生低於這個平均。

5. **友好數**：這題先是想好題目要的邏輯就花了些時間，也去查詢了真因數的定義，瞭解題目要的後，想到之前也有寫過一個題目是找因數，後來決定先將要寫的判斷用中文先大概寫下來，在轉換成程式，中途也發現有些地方不小心帶錯值，後來順利解決，看到排行榜自己在第一頁的第 10 名耶，覺得有點開心，雖然也知道這只是暫時的，也知道如果不將第一題修改成 100 分很快就會被擠到第一頁後了，以及自己的 code 還很爛，優化完如下。
  
    ```javascript
    function factor(n) {
      let trueFactor = [1]
      for (let i = 2; i < n; i ++) {
        if (n % i === 0) {
          trueFactor.push(i)
        }
      }
      return trueFactor
    }

    function addF(trueFactor) {
      let add = 0
      for (let i = 0; i < trueFactor.length; i ++) {
        add += parseInt(trueFactor[i])
      }
      return add
    }

    function pe(n) {
      let trueFactor = factor(n)  
      let add = addF(trueFactor)
      let trueFactor2 = factor(add)
      let add2 = addF(trueFactor2)
      if (add === n) {
        return `=${n}`
      } 
      if (n === add2) {
        return `${add}`
      }
      return `0`
    }
    ```
    原本想將 `factor` 及 `addF` 的 function 融合為一個，看能不能更簡潔，嘗試失敗，測試後發現因為我融合為一個的 function 會執行兩次，但這兩次回傳出來的名稱是一樣的，就無法分別取出值。
    例如都會回傳 add 及 trueFactor 像是 `{ add: 284,
      trueFactor: [ 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110 ] }` 取出來的話嘗試後發現要與名稱一樣，就是用 add 及 trueFactor命名的方式解構出來，但如果兩次都這樣取就會錯誤重複宣告了。（錯誤的地方如下 pe 的 function 內的註解附近）
    ```javascript
    // 失敗的優化
    function factor(n) {
      let trueFactor = [1]
      for (let i = 2; i < n; i ++) {
        if (n % i === 0) {
          trueFactor.push(i)
        }
      }
      let add = 0
      for (let i = 0; i < trueFactor.length; i ++) {
        add += parseInt(trueFactor[i])
      }
      return {
        add: add,
        trueFactor: trueFactor,
      }
    }


    function pe(n) {
      let returnFactor = factor(n) 
      let {add, trueFactor} = returnFactor
      let returnFactor2 = factor(add)
      console.log(returnFactor2)  // 印出 { add: 220, trueFactor: [ 1, 2, 4, 71, 142 ] }
      let {trueFactor, add} = returnFactor2
      console.log(trueFactor, add) // 印出 undefined undefined，因為與上面的宣告相同名稱，所以下面就沒有繼續改下去了
      if (add === n) {
        return `=${n}`
      } 
      if (n === add3) {
        return `${add}`
      }
      return `0`
    }
    ```
6. **優惠方案**：這題感覺也算很 ok，稍微想一下，在寫下來就 ok 了，之後的題目想要等後續上課如果自己想睡覺就來解題，或者也可以去解看看 codewars 題目來醒醒。


